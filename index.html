<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LEA ‚Äî Mock Exam</title>

<!-- üå± Emoji favicon (no external file needed) -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üå±</text></svg>">

<meta name="description" content="Interactive mock exam ‚Äî timer, review mode, load progress, manifest-based sets."/>
<style>
  :root{
    --bg:#f6fbf6; --panel:#ecf7ec; --card:#ffffff;
    --primary:#2e7d32; --muted:#6b7280; --accent:#ffb300; --danger:#ef4444;
    --ok:#16a34a; --info:#2563eb;
    --radius:12px; --shadow: 0 6px 18px rgba(18,52,20,0.06);
    --maxw:1200px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#06361a;background:linear-gradient(180deg,#f0faf0,#eaf6ea);-webkit-font-smoothing:antialiased}
  .app{max-width:var(--maxw);margin:18px auto;padding:18px}
  header{display:flex;align-items:center;gap:12px;margin-bottom:14px}
  .brand{display:flex;align-items:center;gap:12px}
  .logo{width:80px;height:80px;border-radius:12px;background:linear-gradient(135deg,var(--primary),#66bb6a);display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:40px;line-height:1;box-shadow:var(--shadow)}
  h1{margin:0;font-size:20px}

  /* RIGHT HEADER CONTROLS (right-aligned stack) */
  .controls{
    margin-left:auto;
    display:flex;
    flex-direction:column;
    align-items:flex-end;
    gap:6px;
  }
  .controls-top{
    display:flex;
    align-items:center;
    gap:8px;
  }

  /* Badges */
  .badge{
    font-size:15px;
    font-weight:800;
    padding:8px 12px;
    border-radius:999px;
    line-height:1;
    box-shadow:var(--shadow);
    white-space:nowrap;
  }
  .badge--progress{
    color:#fff;
    background:linear-gradient(90deg,#0ea5e9,#2563eb);
  }
  .badge--score{
    color:#06361a;
    background:linear-gradient(90deg,#ffd86b,#ffb300);
  }

  .small{font-size:13px;color:var(--muted)}
  .card{background:var(--card);border-radius:var(--radius);padding:12px;box-shadow:var(--shadow)}
  .layout{display:grid;grid-template-columns:260px 1fr;gap:12px}

  /* Sidebar */
  aside{display:flex;flex-direction:column;gap:12px}
  #qGrid{display:grid;grid-template-columns:repeat(5,1fr);gap:6px;max-height:520px;overflow:auto;padding:6px}
  .qnum{background:linear-gradient(180deg,#f8fffb,#f0fff0);border-radius:8px;padding:8px;text-align:center;cursor:pointer;border:1px solid rgba(10,60,20,0.05);font-weight:600}
  .qnum.current{outline:2px solid rgba(46,125,50,0.18)}
  .qnum.answered{background:linear-gradient(90deg,#16a34a,#059669);color:#fff}
  .qnum.correct{background:#16a34a;color:white}
  .qnum.wrong{background:#ef4444;color:white}

  /* Main */
  main{display:flex;flex-direction:column;gap:12px}
  .meta{display:flex;align-items:center;gap:12px}
  #timer{font-weight:700;color:var(--card);background:linear-gradient(90deg,var(--accent),#ffd86b);padding:6px 10px;border-radius:8px}
  #progressWrap{flex:1}
  .progress{height:10px;background:rgba(0,0,0,0.06);border-radius:999px;overflow:hidden}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--primary),#66bb6a);width:0%}
  .question-card{padding:18px;border-radius:12px;background:linear-gradient(180deg,#ffffff,#f7fff7);box-shadow:var(--shadow)}
  #questionText{font-size:18px;margin-bottom:12px}
  #choices{display:flex;flex-direction:column;gap:10px}
  .choice{background:transparent;border:2px solid rgba(6,54,26,0.06);padding:12px;border-radius:10px;cursor:pointer;text-align:left;display:flex;gap:12px;align-items:center}
  .choice:hover{transform:translateY(-2px)}
  .choice .letter{width:34px;height:34px;border-radius:8px;background:rgba(6,54,26,0.06);display:flex;align-items:center;justify-content:center;font-weight:700}
  .choice.selected{background:linear-gradient(90deg,#e6f8ea,#d1f0d9);border-color:rgba(6,54,26,0.12)}
  .choice.correct{background:linear-gradient(90deg,#16a34a33,#16a34a22);border-color:rgba(22,163,74,0.3)}
  .choice.wrong{background:linear-gradient(90deg,#ef444433,#ef444422);border-color:rgba(239,68,68,0.25)}
  .nav{display:flex;gap:8px;align-items:center;margin-top:12px}
  .nav .spacer{flex:1}

  /* Buttons */
  button.btn{background:var(--primary);color:white;padding:10px 12px;border-radius:8px;border:0;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(6,54,26,0.06);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
  button.btn, button.ghost { transition: all 0.2s ease, transform 0.15s ease; }
  button.btn:hover { background:#256928; box-shadow:0 4px 12px rgba(0,0,0,0.15); transform:translateY(-2px); }
  button.btn:active { transform:scale(0.97); box-shadow:0 2px 6px rgba(0,0,0,0.2) inset; }
  button.ghost:hover { background:rgba(6,54,26,0.05); border-color:rgba(6,54,26,0.2); transform:translateY(-2px); box-shadow:0 2px 6px rgba(0,0,0,0.08); }
  button.ghost:active { transform:scale(0.97); box-shadow:0 2px 4px rgba(0,0,0,0.15) inset; }

  .qnum { transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease; }
  .qnum:hover { transform:translateY(-2px); box-shadow:0 4px 10px rgba(0,0,0,0.08); border-color:rgba(10,60,20,0.12); }
  .qnum:active { transform:scale(0.97); box-shadow:inset 0 2px 4px rgba(0,0,0,0.12); }

  .tools{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  footer.small{font-size:13px;color:var(--muted);margin-top:10px}

  /* Modals (shared) */
  .modal{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    background:rgba(3,20,10,0.45);z-index:60;
    opacity:0; pointer-events:none; transition:opacity .25s ease;
  }
  .modal.show{ opacity:1; pointer-events:auto; }
  .modal .box{
    background:white;padding:22px;border-radius:12px;min-width:320px;max-width:90%;text-align:center;
    box-shadow:var(--shadow);
    transform:translateY(8px) scale(.98); opacity:0; transition:transform .25s ease, opacity .25s ease;
  }
  .modal.show .box{ transform:translateY(0) scale(1); opacity:1; }
  .result-big{font-size:22px;font-weight:800;color:var(--primary);margin:8px 0}

  /* Time-up modal extras */
  #timeUpModal{ z-index:70; } /* above other modals */
  .pulse{
    width:72px;height:72px;border-radius:16px;margin:0 auto 10px auto;
    background:conic-gradient(from 0deg, #66bb6a, var(--primary));
    display:flex;align-items:center;justify-content:center;color:#fff;font-size:32px;font-weight:800;
    position:relative; overflow:hidden;
  }
  .pulse::after{
    content:''; position:absolute; inset:0; background:radial-gradient(closest-side, rgba(255,255,255,0.35), transparent 55%);
  }

  /* responsive */
  @media(max-width:980px){
    .layout{grid-template-columns:1fr;gap:10px}
    aside{order:2}
    .brand h1{font-size:18px}
    #qGrid{grid-template-columns:repeat(10,1fr)}
  }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="logo">üå±</div>
        <div>
          <h1>Review Questions ‚Äî Mock Exam</h1>
          <div class="small">LEZGO! One step a time.</div>
        </div>
      </div>

      <div class="controls">
        <div class="controls-top">
          <div id="statusBadge" class="badge badge--progress" role="status" aria-live="polite">
            Answered: <strong id="answeredCount">0</strong>/<strong id="totalQ">0</strong>
          </div>
          <div id="timer" title="Time remaining">--:--:--</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end">
          <select id="categorySelect" class="ghost" style="padding:6px;border-radius:8px;min-width:180px">
            <option value="">Select category‚Ä¶</option>
          </select>
          <select id="setSelect" class="ghost" style="padding:6px;border-radius:8px;min-width:180px" disabled>
            <option value="">Select set‚Ä¶</option>
          </select>
          <button id="loadSetBtn" class="btn" disabled>Load set</button>
          <button id="loadBtn" class="ghost" title="Load progress (L)">Load</button>
        </div>
      </div>
    </header>

    <div class="meta" style="margin-bottom:8px">
      <div id="examTitle" class="small">Exam: (no set loaded)</div>
      <div id="progressWrap">
        <div class="progress"><i id="progressFill"></i></div>
      </div>
      <div class="tools">
        <label class="small">Timer (mins): <input id="timerInput" type="number" value="60" min="0.01" step="0.01" style="width:70px;margin-left:6px"></label>
      </div>
    </div>

    <div class="layout">
      <!-- SIDEBAR -->
      <aside class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small">Navigator</div>
          <div class="small"><button id="clearAnswers" class="ghost" title="Clear all answers">Clear</button></div>
        </div>

        <div id="qGrid" aria-label="Question grid"></div>
      </aside>

      <!-- MAIN -->
      <main>
        <div class="question-card card" id="questionCard">
          <div style="display:flex;justify-content:space-between;align-items:flex-start">
            <div>
              <div class="small">Question <strong id="qIndex">1</strong> / <strong id="totalQs">0</strong></div>
              <div id="questionText">Pick a category and set, then click ‚ÄúLoad set‚Äù.</div>
            </div>
            <div class="small" style="text-align:right">Keyboard: ‚Üê/‚Üí to navigate ‚Ä¢ 1‚Äì4 to answer</div>
          </div>

          <div id="choices" style="margin-top:14px"></div>

          <div class="nav">
            <button id="prevBtn" class="ghost">‚Üê Previous</button>
            <button id="nextBtn" class="ghost">Next ‚Üí</button>
            <div class="spacer"></div>
            <button id="submitBtn" class="btn">Submit exam</button>
          </div>
        </div>

        <footer class="small">Tip: Choices and question order are randomized automatically.</footer>
      </main>
    </div>
  </div>

  <!-- Result Modal -->
  <div id="resultModal" class="modal hidden" style="display:none">
    <div class="box" role="dialog" aria-labelledby="resultTitle" aria-modal="true">
      <h3 id="resultTitle">Exam Results</h3>
      <div class="result-big" id="scoreText">0 / 0</div>
      <div class="small" id="percentText">0%</div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
        <button id="closeResult" class="ghost">Close</button>
      </div>
    </div>
  </div>

  <!-- Time-Up Modal (custom instead of alert) -->
  <div id="timeUpModal" class="modal hidden" style="display:none">
    <div class="box" role="dialog" aria-labelledby="timeUpTitle" aria-describedby="timeUpDesc" aria-modal="true">
      <div class="pulse" aria-hidden="true">‚è∞</div>
      <h3 id="timeUpTitle" style="margin:6px 0 2px 0">Time is up!</h3>
      <p id="timeUpDesc" class="small" style="margin:0 0 6px 0">Your exam is being submitted automatically.</p>
      <div style="margin-top:10px;display:flex;gap:8px;justify-content:center">
        <button id="timeUpOk" class="btn" autofocus>Okay</button>
      </div>
    </div>
  </div>

<script>
/* === App state === */
let QUESTIONS = [];            // array of {question, choices[], answer}
let USER = [];                 // array user answers (index or null)
let CURRENT = 0;
let TOTAL = 0;
let TIMER = null;
let reviewMode = false;

/* --- DOM refs --- */
const qGrid = document.getElementById('qGrid');
const qIndexEl = document.getElementById('qIndex');
const totalQsEl = document.getElementById('totalQs');
const questionText = document.getElementById('questionText');
const choicesEl = document.getElementById('choices');
const answeredCountEl = document.getElementById('answeredCount');
const totalQEl = document.getElementById('totalQ');
const progressFill = document.getElementById('progressFill');
const timerEl = document.getElementById('timer');
const resultModal = document.getElementById('resultModal');
const scoreText = document.getElementById('scoreText');
const percentText = document.getElementById('percentText');
const statusBadge = document.getElementById('statusBadge');
const submitBtn = document.getElementById('submitBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const clearAnswersBtn = document.getElementById('clearAnswers');
const loadBtn = document.getElementById('loadBtn');
const closeResultBtn = document.getElementById('closeResult');
const timerInput = document.getElementById('timerInput');

/* New: time-up modal refs */
const timeUpModal = document.getElementById('timeUpModal');
const timeUpOk = document.getElementById('timeUpOk');

/* Picker refs */
const categorySelect = document.getElementById('categorySelect');
const setSelect = document.getElementById('setSelect');
const loadSetBtn = document.getElementById('loadSetBtn');

/* --- Helpers --- */
function safeText(s){ return String(s||'').replace(/\s+$/,'').trim(); }
function formatTime(s){
  if (s<0) s=0;
  const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), sec = s%60;
  return (h>0? String(h).padStart(2,'0')+':' : '') + String(m).padStart(2,'0') + ':' + String(sec).padStart(2,'0');
}

/* Status badge helpers */
function setProgressBadge(){
  statusBadge.classList.remove('badge--score');
  statusBadge.classList.add('badge','badge--progress');
}
function setScoreBadge(){
  statusBadge.classList.remove('badge--progress');
  statusBadge.classList.add('badge','badge--score');
}

function updateAnsweredCount(){ 
  const count = USER.filter(x=>x!==null).length;
  answeredCountEl.textContent = count;
  totalQEl.textContent = TOTAL;
  document.getElementById('totalQs').textContent = TOTAL;
  document.getElementById('answeredCount').textContent = count;
  document.getElementById('totalQ').textContent = TOTAL;
  progressFill.style.width = TOTAL? Math.round((count/TOTAL)*100) + '%' : '0%';

  if (!reviewMode){
    statusBadge.innerHTML = `Answered: <strong id="answeredCount">${count}</strong>/<strong id="totalQ">${TOTAL}</strong>`;
    setProgressBadge();
  }
}
function shuffleArray(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
}

/* --- Build grid --- */
function buildGrid(){
  qGrid.innerHTML = '';
  for(let i=0;i<TOTAL;i++){
    const btn = document.createElement('button');
    btn.className = 'qnum';
    btn.textContent = i+1;
    btn.dataset.i = i;
    btn.addEventListener('click', ()=>{ reviewMode ? renderReviewQuestion(i) : renderQuestion(i); });
    qGrid.appendChild(btn);
  }
  refreshGrid();
}

/* --- Refresh grid (aware of review mode) --- */
function refreshGrid(){
  const nodes = qGrid.querySelectorAll('.qnum');
  nodes.forEach(n=>{
    const i = Number(n.dataset.i);
    n.classList.toggle('current', i===CURRENT);

    if (reviewMode){
      n.classList.remove('answered');   // keep correct/wrong colors
    } else {
      n.classList.toggle('answered', USER[i] !== null);
      n.classList.remove('correct','wrong');
    }
  });
}

/* --- Render question --- */
function renderQuestion(idx){
  if (idx < 0) idx = 0;
  if (idx >= TOTAL) idx = TOTAL-1;
  CURRENT = idx;
  qIndexEl.textContent = idx+1;
  questionText.textContent = safeText(QUESTIONS[idx]?.question || '(no question)');
  choicesEl.innerHTML = '';
  const choices = QUESTIONS[idx]?.choices || [];
  choices.forEach((c,i)=>{
    const el = document.createElement('div');
    el.className = 'choice';
    el.setAttribute('role','button');
    el.setAttribute('aria-pressed', USER[idx] === i ? 'true' : 'false');
    if (!reviewMode && USER[idx] === i) el.classList.add('selected');
    el.innerHTML = `<div class="letter">${String.fromCharCode(65+i)}</div><div style="flex:1">${c}</div>`;
    if (!reviewMode){
      el.tabIndex = 0;
      el.addEventListener('click', ()=> selectAnswer(idx,i));
      el.addEventListener('keydown', (e)=>{ if (e.key==='Enter' || e.key===' ') selectAnswer(idx,i); });
    } else {
      el.setAttribute('aria-disabled','true');
    }
    choicesEl.appendChild(el);
  });
  refreshGrid();
  updateAnsweredCount();
}

/* --- Answer selection (silent autosave) --- */
function selectAnswer(qIdx, cIdx){
  if (reviewMode) return;
  USER[qIdx] = cIdx;
  saveProgressToLocal(false);
  renderQuestion(qIdx);
}

/* --- Load questions (with optional randomization) --- */
function loadQuestionsFromArray(arr, shouldRandomize=false){
  QUESTIONS = arr.map((q,idx)=>({
    question: q.question || q.prompt || `Question ${idx+1}`,
    choices: Array.isArray(q.choices) ? q.choices.slice(0,4) : [],
    answer: (typeof q.answer === 'number' ? q.answer : (q.answer === null ? null : (typeof q.correct === 'number'? q.correct : null)))
  }));

  // sanitize answers
  QUESTIONS.forEach(q=>{
    if(q.answer === null || q.answer >= q.choices.length || q.answer < 0) q.answer = null;
  });

  // Shuffle choices per question and fix answer index
  if (shouldRandomize){
    QUESTIONS.forEach(q=>{
      const arr = q.choices.map((ch,idx)=>({choice: ch, idx}));
      shuffleArray(arr);
      q.choices = arr.map(a=>a.choice);
      if(q.answer !== null){
        const newIndex = arr.findIndex(a=>a.idx === q.answer);
        q.answer = newIndex === -1 ? null : newIndex;
      }
    });
  }

  TOTAL = QUESTIONS.length;
  USER = new Array(TOTAL).fill(null);

  // Shuffle question order
  if (shouldRandomize){
    const zipped = QUESTIONS.map((q,i)=>({q, a: USER[i]}));
    shuffleArray(zipped);
    QUESTIONS = zipped.map(z=>z.q);
    USER = zipped.map(z=>z.a);
  }

  reviewMode = false;
  CURRENT = 0;
  renderQuestion(0);
  buildGrid();
  updateAnsweredCount();
  submitBtn.disabled = false;
  prevBtn.disabled = false;
  nextBtn.disabled = false;
}

/* --- Submit exam (supports forced submit without confirmations) ---
   Added: showResult parameter (default true) so timeout can skip extra popups if needed */
function submitExam(force = false, showResult = true){
  if(reviewMode) return;

  if(!force){
    const unanswered = USER.filter(x=>x===null).length;
    if(unanswered>0){
      if(!confirm(`You have ${unanswered} unanswered questions. Submit anyway?`)) return;
    }
    if(!confirm('Submit exam? You will not be able to change your answers after submitting.')) return;
  }

  reviewMode = true;

  // Disable buttons that allow changes
  submitBtn.disabled = true;
  prevBtn.disabled = true;
  nextBtn.disabled = true;

  // Calculate score
  let correct = 0;
  for(let i=0; i<TOTAL; i++){
    if(USER[i] === QUESTIONS[i].answer) correct++;
  }

  // Convert "Answered" badge ‚Üí "Score" badge
  statusBadge.textContent = `Score: ${correct} / ${TOTAL}`;
  setScoreBadge();

  // Mark grid cells, then render current question
  updateGridForReview();
  renderReviewQuestion(CURRENT);

  // Show result modal (optional)
  if (showResult){
    scoreText.textContent = `${correct} / ${TOTAL}`;
    percentText.textContent = TOTAL ? ((correct/TOTAL)*100).toFixed(2) + '%' : '0%';
    resultModal.style.display = 'flex';
    // small tick to allow display to attach before anim
    setTimeout(()=> resultModal.classList.add('show'), 10);
  }
}

/* --- Render question in review mode --- */
function renderReviewQuestion(idx){
  if(idx < 0) idx = 0;
  if(idx >= TOTAL) idx = TOTAL - 1;
  CURRENT = idx;
  qIndexEl.textContent = idx + 1;
  questionText.textContent = safeText(QUESTIONS[idx]?.question || '(no question)');
  choicesEl.innerHTML = '';
  const choices = QUESTIONS[idx]?.choices || [];
  choices.forEach((c,i)=>{
    const el = document.createElement('div');
    el.className = 'choice';
    if(USER[idx] === i && i === QUESTIONS[idx].answer){
      el.classList.add('correct');
    } else if(USER[idx] === i && i !== QUESTIONS[idx].answer){
      el.classList.add('wrong');
    }
    else if(i === QUESTIONS[idx].answer){
      el.classList.add('correct');
    }
    el.innerHTML = `<div class="letter">${String.fromCharCode(65+i)}</div><div style="flex:1">${c}</div>`;
    el.setAttribute('aria-disabled','true');
    choicesEl.appendChild(el);
  });
  refreshGrid();
  updateAnsweredCount();
}

/* --- Update grid after submit --- */
function updateGridForReview(){
  const nodes = qGrid.querySelectorAll('.qnum');
  nodes.forEach(n=>{
    const i = Number(n.dataset.i);
    n.classList.remove('current','answered','correct','wrong');
    if(USER[i] !== null && QUESTIONS[i].answer !== null){
      if(USER[i] === QUESTIONS[i].answer){
        n.classList.add('correct');
      } else {
        n.classList.add('wrong');
      }
    }
    if(i === CURRENT) n.classList.add('current');
  });
}

/* --- Navigation --- */
prevBtn.addEventListener('click', ()=> {
  if(CURRENT > 0) {
    CURRENT--;
    reviewMode ? renderReviewQuestion(CURRENT) : renderQuestion(CURRENT);
  }
});
nextBtn.addEventListener('click', ()=>{
  if(CURRENT < TOTAL-1) {
    CURRENT++;
    reviewMode ? renderReviewQuestion(CURRENT) : renderQuestion(CURRENT);
  }
});
qGrid.addEventListener('click', (e)=>{
  if(e.target && e.target.matches('button.qnum')){
    const idx = Number(e.target.dataset.i);
    reviewMode ? renderReviewQuestion(idx) : renderQuestion(idx);
  }
});

/* --- Keyboard navigation --- */
document.addEventListener('keydown', (e)=>{
  if(reviewMode) return;
  if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

  if(e.key === 'ArrowLeft' || e.key==='ArrowUp'){
    e.preventDefault();
    if(CURRENT > 0) renderQuestion(CURRENT-1);
  }
  else if(e.key === 'ArrowRight' || e.key==='ArrowDown'){
    e.preventDefault();
    if(CURRENT < TOTAL-1) renderQuestion(CURRENT+1);
  }
  else if(['1','2','3','4'].includes(e.key)){
    e.preventDefault();
    const choiceIndex = Number(e.key)-1;
    if(CURRENT >= 0 && CURRENT < TOTAL){
      if(QUESTIONS[CURRENT].choices.length > choiceIndex){
        selectAnswer(CURRENT, choiceIndex);
      }
    }
  }
});

/* --- Clear all answers --- */
clearAnswersBtn.addEventListener('click', ()=>{
  if(!confirm('Clear all your answers?')) return;
  USER.fill(null);
  reviewMode = false;
  CURRENT = 0;
  submitBtn.disabled = false;
  prevBtn.disabled = false;
  nextBtn.disabled = false;

  // Reset badge back to "Answered"
  statusBadge.innerHTML = `Answered: <strong id="answeredCount">0</strong>/<strong id="totalQ">${TOTAL}</strong>`;
  setProgressBadge();

  renderQuestion(0);
  buildGrid();
  updateAnsweredCount();
});

/* --- Submit button --- */
submitBtn.addEventListener('click', submitExam);

/* --- Result modal --- */
closeResultBtn.addEventListener('click', ()=>{
  resultModal.classList.remove('show');
  setTimeout(()=> resultModal.style.display = 'none', 250);
});

/* --- Save/Load progress from localStorage --- */
function saveProgressToLocal(alertUser=true){
  if(TOTAL === 0) return;
  const data = {
    questions: QUESTIONS,
    userAnswers: USER,
    current: CURRENT,
    timestamp: Date.now()
  };
  try {
    localStorage.setItem('mockExamData', JSON.stringify(data));
    if(alertUser) alert('Progress saved.');
  } catch(e){
    alert('Failed to save progress.');
  }
}
function loadProgressFromLocal(){
  try {
    const data = JSON.parse(localStorage.getItem('mockExamData'));
    if(data && Array.isArray(data.questions) && Array.isArray(data.userAnswers)){
      QUESTIONS = data.questions;
      USER = data.userAnswers;
      TOTAL = QUESTIONS.length;
      CURRENT = data.current || 0;
      reviewMode = false;
      submitBtn.disabled = false;
      prevBtn.disabled = false;
      nextBtn.disabled = false;
      buildGrid();
      renderQuestion(CURRENT);
      updateAnsweredCount();
      alert('Progress loaded.');
      return true;
    }
  } catch(e){}
  alert('No saved progress found.');
  return false;
}
loadBtn.addEventListener('click', loadProgressFromLocal);

/* --- Timer --- */
let timerSeconds = 3600; // default 1hr
timerInput.addEventListener('change', e=>{
  const val = Number(e.target.value);
  if(val > 0){
    timerSeconds = Math.max(1, Math.round(val * 60)); // supports decimals (< 1 minute)
  }
});

/* New: custom time-up modal logic */
function openTimeUpModal(){
  timeUpModal.style.display = 'flex';
  setTimeout(()=> timeUpModal.classList.add('show'), 10);
}
function closeTimeUpModal(){
  timeUpModal.classList.remove('show');
  setTimeout(()=> timeUpModal.style.display = 'none', 250);
}
timeUpOk.addEventListener('click', closeTimeUpModal);

function resetTimer(){
  if(TIMER) clearInterval(TIMER);
  timerEl.textContent = formatTime(timerSeconds);
  TIMER = setInterval(()=>{
    timerSeconds--;
    timerEl.textContent = formatTime(timerSeconds);
    if(timerSeconds<=0){
      clearInterval(TIMER);

      // üîî Show custom modal instead of alert, then auto-submit
      openTimeUpModal();

      // Give the modal a moment to animate in, then submit.
      setTimeout(()=>{
        // submit with force, but don't spawn result immediately under the time-up modal
        submitExam(true, /*showResult=*/true);
      }, 600);
    }
  },1000);
}
// Do not start timer on load

/* === Manifest-driven set loader === */
let MANIFEST = null;
let FILE_BY_SET_ID = new Map();

async function fetchManifest(){
  const res = await fetch('questions/index.json', { cache: 'no-cache' });
  if(!res.ok) throw new Error('Failed to load question manifest.');
  return res.json();
}
function populateCategorySelect(){
  categorySelect.innerHTML = '<option value="">Select category‚Ä¶</option>';
  MANIFEST.categories.forEach(cat=>{
    const opt = document.createElement('option');
    opt.value = cat.id;
    opt.textContent = cat.label || cat.id;
    categorySelect.appendChild(opt);
  });
}
function populateSetSelect(catId){
  setSelect.innerHTML = '<option value="">Select set‚Ä¶</option>';
  setSelect.disabled = true;
  loadSetBtn.disabled = true;
  const cat = MANIFEST.categories.find(c => c.id === catId);
  if(!cat) return;
  FILE_BY_SET_ID = new Map();
  cat.sets.forEach(s=>{
    const opt = document.createElement('option');
    opt.value = s.id;
    opt.textContent = s.label || s.id;
    setSelect.appendChild(opt);
    FILE_BY_SET_ID.set(s.id, s.file);
  });
  setSelect.disabled = false;
}
async function fetchAndLoadSet(setId){
  const file = FILE_BY_SET_ID.get(setId);
  if(!file){ alert('Unknown set.'); return; }
  try{
    const res = await fetch(file, { cache: 'no-cache' });
    if(!res.ok) throw new Error('Failed to fetch questions.');
    const arr = await res.json();
    loadQuestionsFromArray(arr, /*shouldRandomize=*/true);
    const catLabel = categorySelect.selectedOptions[0]?.textContent || 'Exam';
    const setLabel = setSelect.selectedOptions[0]?.textContent || '';
    document.getElementById('examTitle').textContent = `Exam: ${catLabel} ‚Äî ${setLabel}`;

    // Start the timer ONLY after a set is loaded (supports decimal minutes)
    const mins = Math.max(0.01, Number(timerInput.value) || 60);
    timerSeconds = Math.max(1, Math.round(mins * 60));
    resetTimer();

    // Reset the badge to "Answered" for a new run
    statusBadge.innerHTML = `Answered: <strong id="answeredCount">0</strong>/<strong id="totalQ">${TOTAL}</strong>`;
    setProgressBadge();

  }catch(err){
    console.error(err);
    alert('Could not load the selected set.');
  }
}

/* Picker events */
categorySelect.addEventListener('change', e=>{
  populateSetSelect(e.target.value);
});
setSelect.addEventListener('change', e=>{
  loadSetBtn.disabled = !e.target.value;
});
loadSetBtn.addEventListener('click', ()=>{
  if(setSelect.value) fetchAndLoadSet(setSelect.value);
});

/* Boot */
(async function init(){
  // Disable buttons that require questions before loaded
  submitBtn.disabled = true;
  prevBtn.disabled = true;
  nextBtn.disabled = true;
  updateAnsweredCount();

  try{
    MANIFEST = await fetchManifest();
    populateCategorySelect();
  }catch(e){
    console.error(e);
    alert('Manifest not found. Make sure questions/index.json exists.');
  }
})();
</script>
</body>
</html>
